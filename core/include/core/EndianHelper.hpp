/*
 * Copyright (C) 2024 Commissariat à l'énergie atomique et aux énergies alternatives (CEA)

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *    http://www.apache.org/licenses/LICENSE-2.0 

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/

#ifndef _ENDIANHELPER_HPP_
#define _ENDIANHELPER_HPP_

#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include <iostream>
#include <assert.h>
#include <byteswap.h>

namespace vpsim {

//!
//! @namespace EndianHelper
//! @brief A namespace used for definition of global scope helper functions to manage data endianess between host and guest ISS
//!
//! @note Endianess is defined as :
//! increasing numeric significance with increasing memory addresses (or increasing time), known as little-endian, and
//! decreasing numeric significance with increasing memory addresses (or increasing time), known as big-endian
//!
//!
namespace EndianHelper {
//we define every thing in a namespace as we intend to use static functions and not class function for helpers
//namespace is good practice to avoid ambiguity for global scope functions


//!
//! Allows to convert values stored using ISS format uint64_t to a tab of char
//! that can be used for TLM access within VPSim.
//! The behavior depends on the ISS endianess set statically with IsISSBigEndian
//! Indeed relevant bytes are always least significant ones and ISS values are using ISS endianess not host ones
//!
//! @param Val a data generated by ISS for a write access. For accesses smaller than 8 bytes
//! the only significant bytes are the least significant NumBytes
//! @param NumBytes number of relevant bytes inside the 8 bytes Val
//! @tparam IsIssBigEndian allows to implement efficient behavior depending on ISS endianess through compilation time optimization
//! @return al a vector of NumBytes uint8_t corresponding to a portion of memory or a TLM data field
//!
//! @note this does not reverse endianess at all, it only considers relevant bit in data access
//! indeed data accesses shall always respect simulated core's endianess
//!
template <bool IsIssBigEndian>
uint64_t IssValToByteArray(uint64_t Val, int NumBytes){
	//So far, TabVal can't be more than 8 bytes so static allocation of uint64_t makes it.
	uint64_t TabVal{0};
	if (IsIssBigEndian){
		std::cerr<<"WARNING: IssValToByteArray: BigEndian ISS data convertion was never tested yet"<<std::endl;
		memmove (&TabVal ,((uint8_t*) &Val)+(8-NumBytes), NumBytes);
	}
	else{
		TabVal = Val;
	}
	return TabVal;
}

//!
//! Allows to convert TabVal array of uint8_t (as is transferred in TLM packets)
//! to a ISS format uint64_t.
//! The behavior depends on the ISS endianess set statically with IsISSBigEndian
//! Indeed relevant bytes are always least significant ones and ISS values are using ISS endianess not host ones
//!
//! @param TabVal a vector of NumBytes uint8_t corresponding to a portion of memory or a TLM data field
//! @param NumBytes number of relevant bytes inside the 8 bytes Val
//! @tparam IsIssBigEndian allows to implement efficient behavior depending on ISS endianess through compilation time optimization
//! @return an uint64_t corresponding to a ISS value whose significant bits depend of ISS's endianess
//!
//! @note this does not reverse endianess at all, it only considers relevant bit in data access
//! indeed data accesses shall always respect simulated core's endianess
//!
template <bool IsIssBigEndian>
uint64_t ByteArrayToIssVal( uint8_t const * TabVal, int NumBytes){
	uint64_t Val=0;
	if (IsIssBigEndian){
		std::cerr<<"WARNING: ByteArrayToIssVal: BigEndian ISS data conversion was never tested yet"<<std::endl;
		memcpy (((uint8_t*) &Val)+(8-NumBytes),TabVal, NumBytes);
	}
	else{
		memcpy (((uint8_t*) &Val), TabVal, NumBytes);
	}
	return Val;
}

//!
//! Converts a portion of NumBytes bytes of simulated memory (or TLM data field) TabVal to
//! an object of type T with the correct endianess for the simulation host. It is therefore meant for data conversion
//! for cosimulation features.
//!
//! @tparam T the expected return type for host compatible return value
//! @tparam IsGuestBigEndian true if Guest ISA is big endian
//! @tparam IsHostBigEndian  true if host ISA is big endian
//!
//! @param TabVal a vector of uint8_t bytes representing a portion of simulated memory or TLM data field
//! @param NumBytes size of TabVal in bytes
//!
//! @return an object of type T with bytes ordered according to host endianess
//!
template <typename T, bool IsGuestBigEndian, bool IsHostBigEndian>
T GuestToHost( uint8_t const * const TabVal, unsigned NumBytes){

	assert(NumBytes==sizeof(T));

	T tmpVal = *((T*)TabVal);

	if (IsGuestBigEndian == IsHostBigEndian){
		return tmpVal; //straight copy from data
	}else{
		std::cerr<<"WARNING: GuestToHost: unmatching HOST/GUEST endianess not tested yet"<<std::endl;
		if(sizeof(T)==1)
			return tmpVal;
		if(sizeof(T)==2)
			return bswap_16(tmpVal);
		if(sizeof(T)==4)
			return bswap_32(tmpVal);
		if(sizeof(T)==8)
			return bswap_64(tmpVal);
		if(sizeof(T)>8){
			std::cerr<<"WARNING: GuestToHost:  unhandled case : byteswap for word size >8 "<<std::endl;
			return 0;
		}
		//probably way less efficient way of doing byte swapping
		//		T tmp = 0;
		//		for(unsigned i=0; i<NumBytes; ++i){
		//			tmp = tmp | TabVal[i]  ;
		//			tmp = tmp>>8;
		//		}

		//idem for reverse conversion
		//uint8_t * val = new uint8_t[num_bytes];
		//uint64_t tmp = value;
		//for(unsigned i=0; i<num_bytes; ++i){
		//	val[i] = tmp & 0xFF;
		//	tmp = tmp>>8;
		//}
	}
}

//!
//! Converts a an object of type T with the correct endianess for the simulation host
//! to a portion of NumBytes bytes of simulated memory (or TLM data field) TabVal.
//! It is therefore meant for data conversion for cosimulation features.
//!
//! @tparam T input type for host input value Val
//! @tparam IsGuestBigEndian true if Guest ISA is big endian
//! @tparam IsHostBigEndian  true if host ISA is big endian
//!
//! @param Val an object of type T with bytes ordered according to host endianess
//! @param NumBytes size of returned uint8_t vector in bytes
//!
//! @return a vector of bytes representing a portion of simulated memory or TLM data field
//!
template <typename T, bool IsGuestBigEndian, bool IsHostBigEndian>
//uint8_t* HostToGuest(T const Val, unsigned NumBytes){
uint8_t* HostToGuest(T const Val, uint8_t* Ret, unsigned NumBytes){

	assert(NumBytes==sizeof(T));
	T TmpVal;
	//char* Ret = new char[sizeof(T)]; //TODO change this code so as not to call new every time a translation is needed

	if (IsGuestBigEndian == IsHostBigEndian){
		TmpVal =Val;
	}else{
		std::cerr<<"WARNING: HostToGuest: unmatching HOST/GUEST endianess not tested yet"<<std::endl;
		if(sizeof(T)==1)
			TmpVal=Val;
		if(sizeof(T)==2)
			TmpVal= bswap_16(Val);
		if(sizeof(T)==4)
			TmpVal=bswap_32(Val);
		if(sizeof(T)==8)
			TmpVal=bswap_64(Val);
		if(sizeof(T)>8){
			std::cerr<<"WARNING: HostToGuest: unhandled case : byteswap for word size >8 "<<std::endl;
			return 0;
		}
	}

	(*(T*)Ret) = TmpVal;

	return Ret;
}

}; //end namespace EndianHelper
}; //end namespace vpsim

#endif /* _ENDIANHELPER_HPP_ */
